# GIT:
## PARA CONFIGURACIONES INICIALES:
### PARA AGREGAR USUARIO: git config --global user.name "kevin Lopez"
### CORREO ELECTRONICO: git config --global user.name "kevin.lopez@pruebas.com"
### PARA VISUALIZAR LOS CAMBIOS REALIZADOS: git config --global -e 
### PARA EMPEZAR A CREAR EL REPOSITORIO
### PARA INICIALIZAR EL REPOSITORIO: git init
### PARA LIMPIAR LA CONSOLA: CTRL+ L
### INFORMACION(ESTADO) SOBRE LA RAMA: git status
### PARA AGREGAR LOS ARCHIVOS UNO A UNO: git add "nombre y extension del archivo"
### PARA AÑADIR TODOS LOS ARCHIVOS MODIFICADOS: git add .
### PARA SACAR UN ARCHIVO DEL ADD: git reset "NOMBRE DEL ARCHIVO"
### PARA REALIZAR EL COMMIT: git commit -m "PRIMER COMMIT"
### RECONSTRUIR EL PROYECTO A COMO ESTABA EN EL ANTERIOR COMMIT: git checkout -- .
### PARA SABER EN QUE RAMA SE ESTA TRABAJANDO: git branch
### PARA CAMBIAR EL NOMBRE DE LA RAMA(MASTER) A MAIN: git branch -m master main
### PARA COMITEAR UN ARCHIVO SIN HABER AÑADIDO ANTES PERO QUE YA SE LE DABA SEGUIMIENTO: git commit -am "Readme actualizado"
### PARA CAMBIAR DE FORMA GLOBAL EL NOMBRE DE LA MASTER A MAIN: git config --global init.defaultBranch main
### VISUALIZAR HISTORIAL DE COMMITS: git log
### PARA AGREGAR EN EL STAGE SOLO ARCHIVOS DE UNA EXTENSION ESPECIFICA: git add *.html
### PARA AGREGAR AL STAGE TODOS LOS ARCHIVOS Y SUBCARPETAS QUE SE ENCUENTRAN DENTRO DE LA CARPETA "CSS": git add css/
### PARA CREAR UN ALIAS(SIRVE PARA NO TENER QUE ESCRIBIR TODA EL COMANDO)(git status --short): git config --global alias.s status --short
### PARA MODIFICAR EL ALIAS: git config --global -e
### LUEGO SE PRESIONA LA TECLA "A" PARA MODIFICAR EL COMANDO DEL ALIAS
### LUEGO PARA SALIR DE ESA VENTANA: 
### LUEGO "ESC" "WQ!"
### RESUMEN DE DATOS VISUALIZADOS EN EL LOG: git log --oneline
### PARA VISUALIZAR MEJOR LOS COMMIT CON SUS RAMAS Y DIVISIONES: git log --oneline --all --graph
### PARA VER DIFERENCIA ENTRE EL STAGE Y LO QUE NO ESTA: git diff
### PARA VER DIFERENCIAS ENTRE EL STAGE Y EL MAIN: git diff --staged
### PARA CAMBIAR EL NOMBRE DEL COMMIT REALIZADO: git commit --amend - "NOMBRE DEL NUEVO COMMIT"
### PARA VER DATOS DEL COMMIT(PARA MODIFICAR SE PRESIONA LA TECLA A - PARA SALIR ESC:QW!): git commit --amend
### PARA REVERSAR EL COMMIT ANTERIOR SIN AFECTAR EL PROYECTO(YA QUE LOS CAMBIOS DEL COMMIT SE QUEDAN EN EL STAGE) - SE UTILIZA PARA MODIFICAR UN COMMIT: git reset --soft HEAD^
### PARA DESHACER LOS CAMBIOS DE UN COMMIT Y REMOVERLOS DEL STAGE(ES DECIR TODOS LOS COMMIT QUE VINIERON DESPUES DE ESTE REVIERTEN Y SE DESMARCAN DEL STAGE, PERO SIN MODIFICAR LOS CAMBIOS EN EL PRYECTO): git commit --mixed <numero de commit>
### PARA DESHACER LOS CAMBIOS DE UN COMMIT Y REMOVERLOS DEL STAGE Y TAMBIEN DESHACERLOS DEL PROYECTO: git reset --hard <NUMERO DEL COMMIT>
### UNA VEZ APLICADO EL HARD YA NO APARECE LOS COMMIT EN EL LOG PERO PARA VISUALIZAR EN FORMA CRONOLOGICA AUNQUE HAYA APLICADO EL HARD: git reflog
### PARA RECUPERAR EL PROYECTO EN UN PUNTO EN ESPECIFICO SEGUN EL COMMIT: git reset --hard <hash del commit>
### PARA RENOMBRAR UN ARCHIVO SE PUEDE UTILIZAR EL COMANDO MV(QUE ES PARA MOVER UN ARCHIVO PERO SI ESTA EN LA MISMA DIRECCION SOLO LO RENOMBRA): git mv "nombre del archivo" "nuevo nombre de archivo"
### PARA ELIMINAR UN ARCHIVO POR CONSOLA(PERO LO MANTIENE EN EL STAGE PENDIENTE DE COMMIT): git rm "nombre del archivo"
### CUANDO SE TRABAJE CON ARCHIVOS QUE NO SE QUIEREN DAR SEGUIMIENTO(NO SE QUIEREN AGREGAR AL STAGE) SE DEBE CREAR UN ARCHIVO EN LA RAIZ DEL PROYECTO CON EL NOMBRE DE ".gitignore" ADENTRO DEL ARCHIVO SE AGREGAN EL DIRECTORIO O ARCHIVOS DE LO QUE NO SE QUIERE DAR SEGUIMIENTO.
     * **A ESTE ARCHIVO SI HAY QUE DAR SEGUIMIENTO(AGREGAR AL STAGE) Y COMMITEAR.**
### PARA CREAR UNA RAMA POR COMANDO: git branch "NOMBRE DE LA RAMA"
### PARA SABER EN QUE RAMA ESTAS TRABAJANDO(MARCA EN * PARA MOSTRAR LA RAMA ACTUAL): git branch
### PARA MOVERNOS A UNA RAMA ESPECIFICA: git checkout "nombre de la rama"
### PARA UNIR LOS CAMBIOS DE UNA RAMA A OTRA(MERGE)(DEBES ESTAR SITUADO EN LA RAMA A DONDE QUIERES TRAER LOS CAMBIOS): git merge "NOMBRE DE LA RAMA"
### PARA BORRAR UNA RAMA: git branch -d "NOMBRE DE LA RAMA"
### SI LA RAMA A ELIMINAR POSEE CAMBIOS ENTONCES GIT AVISARA QUE NO SE PUEDE ELIMINAR, PARA FORZAR DE IGUAL FORMA LA ELIMINACION: git - d "NOMBRE DE LA RAMA" -f
### PARA CREAR UNA RAMA Y PARA MOVERSE A ELLA: git checkout -b "nombre de la rama"
### PARA CREAR ETIQUETAS-TAGS(PARA EL MOMENTO DE SUBIR A PRODUCCION LOS CAMBIOS): git tag "nombre del tag"
### PARA PUSHEAR LOS TAGS CREADOS: git push --tags
### PARA LISTAR TODOS LOS TAG: git tag
### PARA ELIMINAR UN TAG: git tag -d "nombre del tag"
### PARA CREAR UNA ETIQUETA ANOTADA(INCLUIR MAS DATOS EN LA ETIQUETA O TAG): git tag -a "VERSION" -m "descripcion de la version"
### PARA CREAR UNA ETIQUETA(TAG) A UN COMMIT ESPECIFICO: git tag -a "version" "HASH DEL COMMIT" -m "MENSAJE DE LA VERSION"
### VER MAS INFORMACION DE UN TAG EN ESPECIFICO: git show "VERSION DEL TAG"
### PARA STASHEAR TODOS LOS CAMBIOS INCLUIDOS LOS QUE NO FUERON AGREGAR AL STAGE NI COMITEADOS: git stash
### PARA LISTAR TODOS LOS STASH: git stash list
### PARA RECUPERAR EL ULTIMO STASH: git stash pop
### PARA ELIMINAR TODOS LOS STASH: git stash clear
### PARA RECUPERAR UN STASH ESPECIFICO: git stash apply 'stash@{"NUMERO DEL STASH A RECUPERAR"}'
### PARA ELIMINAR UN STASH ESPECIFICO:git stash drop 'stash@{"NUMERO DEL STASH A RECUPERAR"}'
### PARA VER MAS DETALLES DEL STASH: git stash show 'stash@{"NUMERO DEL STASH A RECUPERAR"}'
### PARA PONER UN NOMBRE A UN STASH: git stash save "DESCRIPCION DEL STASH"
### PARA LISTAR TODOS LOS STASH Y A SU VEZ VER MAS INFORMACION DE CADA UNO: git stash list --stat
### PARA HACER UN REBASE DE LA MASTER A UNA RAMA(UNIR LOS CAMBIOS): git rebase "nombre de la rama"
### PARA REALIZAR UN REBASE INTERACTIVO(REORGANIZAR , UNIR, MODIFICAR O ELIMINAR): git rebase -i HEAD~"NUMERO DE COMMIST QUE SE QUIERE VER EN PANTALLA PARA MODIFICAR"
    * PARA MODIFICAR LOS COMANDOS(A).
        * PARA UNIFICAR DOS COMMITS REEMPLAZAR PICK POR SQUASH(S).
            * EL COMMIT DONDE SE ASIGNA LA S SE UNE CON EL COMMIT ANTERIOR(PARA SALIR: ESC + : + w(para escribir el cambio) + q(para salir))
            * EN LA NUEVA PANTALLA SI NO SE MODIFICA NADA ENTONCES EL NUEVO COMMIT SE QUEDARA CON EL NOMBRE QUE PROPONE GIT(ESC + : + W + Q + !).
        * PARA RENOMBRAR COMMITS REEMPLAZAR PICK POR REWORD(R).
            * UNA VEZ REEMPLAZADO EL PICK POR R PARA SALIR: ESC + : + w(para escribir el cambio) + q(para salir) + !
            * TE LLEVA EN LA NUEVA PANTALLA DONDE MODIFICAS(PRESIONANDO A) LOS NOMBRES DE LOS COMMITS
            * PARA SALIR ESC + : + W + Q + !.
        * PARA EDITAR COMMITS(DE FORMA MANUAL)
            * SE MODIFICA EL PICK POR E(EDIT), LUEGO PARA SALIR: ESC + :WQ!
            * NOS ENCONTRAMOS DENTRO DEL REBASE MANUAL
                * PARA VOLVER ATRAS AL ULTIMO COMMIT: git reset HEAD^
                * SE AGREGAN DE NUEVO ARCHIVO POR ARCHIVO AL STAGE Y LUEGO SE COMITEA DE FORMA NORMAL
                * PARA APLICAR LOS CAMBIOS DEL REBASE: git rebase --continue
### PARA VOLVER LOS CAMBIOS AL ULTIMO COMMIT DE SOLO UN ARCHIVO: git checkout -- "NOMBRE DEL ARCHIVO Y SY EXTENSION"
### SI SE ESTA TRABAJANDO EN LA MASTER Y POR ALGUNA RAZON NO ESTAN EN LA MISMA LINEA DE TIEMPO(GIT LG) LA MASTER CON EL HEAD SE IGUALA: git checkout master
### LOS TAGS NO SE SUBEN DE FORMA AUTOMATICA EN LA NUBE, SE DEBE HACER DE FORMA MANUAL: git push --tags
### PARA TRAER LOS DATOS DESDE EL ORIGEN Y UNIRLOS CON LA RAMA: git pull
### PARA TRAER TODOS LOS CAMBIOS PERO SIN UNIRLOS CON LA RAMA: git fetch
### PARA SABER EN QUE URL ESTA EL REPOSITORIO: git remote -v
### PARA CLONAR UN REPOSITORIO DESDE EL CMD DEBEMOS INGRESAR EN LA CARPETA DONDE QUERES CLONAR(CD): git clone "LINK DEL REPOSITORIO"
### PARA SUBIR LOS CAMBIOS AL SERVIDOR REMOTO: git push
### PARA CAMBIAR LA CONFIGURACION DEL PULL, PARA QUE REALICE UN REBASE EN LUGAR DE UN MERGE: git config pull.rebase true
### PARA QUE EL PULL SEA CON FAST-FORWARD Y NO CON REBASE: git config --global pull.ff only
### PARA SABER TODOS LOS COMMIT QUE SE HICIERON EN UNA RAMA EN ESPECIFICA: git log --name-only "NOMBRE DE LA RAMA"
### PARA VOLVER UN SOLO ARCHIVO A COMO ESTABA EN UN COMMIT ANTERIOR: git checkout "HASH DEL COMMIT" "NOMBRE Y EXTENSION DEL ARCHIVO"
### PARA VER DETALLES DE UN SOLO COMMIT: git show --name-only "HASH DEL COMMIT"
### PARA VERIFICAR TODAS LAS RAMAS QUE SE ENCUENTRAN EN EL REPOSITORIO: git branch -a
### PARA SUBIR LOS CAMBIOS LOCALES DE UNA RAMA AL REPOSITORIO REMOTO Y AL MISMO TIEMPO ESTABLECER SEGUIMIENTO ENTRE EL LOCAL Y EL REMOTO(PUBLICAR LA RAMA AL REMOTO): git push --set-upstream origin "NOMBRE RAMA"
### PARA MOSTRAR EL ESTADO DE FORMA CORTA ADEMAS DE LA RAMA EN LA CUAL ESTA SITUADO: git status --short -b
### PARA MOSTRAR EL ESTADO DE FORMA CORTA DEMAS DE LA RAMA EN LA CUAL ESTA SITUADO(S: SHORT/ B: BRANCH): git status -sb
### PARA TRAER A LA RAMA ACTUAL INCLUSIVE LOS CAMBIOS DE RAMAS DE OTRAS PERSONAS: git pull --all
### PARA VER TODAS LAS RAMAS EXISTENTES INCLUSO EN LAS QUE YO NO PARTICIPO(a: all): git branch -a
### PARA ACTUALIZAR LAS REFERENCIAS(COMO RAMAS ELIMINADAS EN LA NUBE PARA IGUALARLAS CON LO LOCAL): git remote prune origin
### PARA CERRAR UN ISSUE POR COMENADO: git commit -am "Fixes #5:(EL NUMERO DEBE HACER REFERENCIA AL ISSUE) "COMENTARIO DEL COMMIT""
### PARA STAGEAR UN ARCHIVO POR PARTES:
    * PRIMERO SE DEBE SELECCIONAR EL ARCHIVO: git add -p "NOMBRE DEL ARCHIVO"
        * "y" STAGEA ESTE FRAGMENTO
        * "n" NO STAGEA ESTE FRAGMENTO
        * "q" SALIR DEL PROCESO DE STAGING
        * "a" STAGEA ESTE FRAGMENTO Y TODOS LOS SIGUIENTES FRAGMENTOS EN EL ARCHIVO.
        * "d" NO STAGEA ESTE FRAGMENTO NI LOS SIGUIENTES FRAGMENTOS EN EL ARCHIVO.